# Zero-Reflection Compile-Time Architecture Design

## Overview

Pico.DI implements a **zero-reflection, compile-time factory generation** architecture where:
- ✅ All service factories are generated at compile-time by the Roslyn source generator
- ✅ Runtime code contains only placeholder methods (like `return this;`)
- ✅ No reflection happens at runtime - all type information is static
- ✅ Fully AOT-compatible with Native AOT and IL trimming

## Core Architecture Principle

### Traditional DI Container Approach ❌
```
Application Code
    ↓
Register(Type serviceType, Type implType) ← Runtime type handling
    ↓
Container uses reflection to analyze constructors ← Runtime reflection
    ↓
Factory delegates created at runtime ← Runtime code generation
    ↓
Call factory to create instances ← Runtime execution
```

### Pico.DI Compile-Time Approach ✅
```
Application Code
    ↓
Register<T, TImpl>() ← Generic type parameters (compile-time known)
    ↓
Source Generator scans this call
    ↓
Generator generates complete factory code ← Compile-time code generation
    ↓
Generated code calls Register(SvcDescriptor) with pre-built factory
    ↓
Runtime: descriptor contains pre-built factory (no reflection needed)
    ↓
GetService() calls pre-generated factory directly ← Zero reflection
```

## Dual-Mode Architecture

Extension methods like `RegisterSingleton<TService, TImpl>()` work in **two modes**:

### Mode 1: Compile-Time (Production with Source Generator) ⚡

When the Roslyn source generator runs:
1. **Scans** all `RegisterSingleton<IUser, User>()` calls
2. **Generates** explicit factory code at compile-time
3. **Produces** `ConfigureGeneratedServices()` method with pre-built factories
4. Extension method itself is **never called** - generator produces direct `Register(SvcDescriptor)` calls

### Mode 2: Runtime Fallback (Testing/Manual Registration)

If `RegisterSingleton<TService, TImpl>()` is called at runtime:
- Creates a simple `Activator.CreateInstance<TImpl>()` factory
- Allows tests to work without source generator
- Useful for dynamic scenarios

**Combined Result**: Best of both worlds:
- ✅ **Production**: Zero reflection via pre-generated factories
- ✅ **Testing**: Runtime fallback allows manual registration

## The Three Phases (Production Path)

### Phase 1: Compile-Time (Source Generator)

**What happens**: The `ServiceRegistrationGenerator` analyzes your code:

```csharp
// Your application code
container
    .RegisterSingleton<IUser, User>()
    .RegisterTransient<IEmailService, EmailService>();
```

The generator:
1. **Scans** for all `Register*` calls using Roslyn syntax analysis
2. **Analyzes** constructor parameters of each implementation type
3. **Generates** explicit, pre-compiled factory code (not reflection-based)
4. **Produces** a `GeneratedServiceRegistrations` class with `ConfigureGeneratedServices()` method

### Phase 2: Code Generation Output

The source generator produces (auto-generated):

```csharp
// Auto-generated by Pico.DI.Gen source generator
// File: Pico.DI.Gen/GeneratedServiceRegistrations.cs

public static class GeneratedServiceRegistrations
{
    public static ISvcContainer ConfigureGeneratedServices(
        this ISvcContainer container)
    {
        // For production: explicit factory code (zero reflection)
        container.Register(new SvcDescriptor(
            typeof(IUser),
            static _ => new User(),  // ← Explicit compiled code, not Activator.CreateInstance
            SvcLifetime.Singleton));

        // For dependencies: statically resolved at compile-time
        container.Register(new SvcDescriptor(
            typeof(IEmailService),
            static scope => new EmailService(
                (ILogger)scope.GetService(typeof(ILogger))  // ← Type known at compile-time
            ),
            SvcLifetime.Transient));

        return container;
    }
}
```

**Key Points**:
- Factories are **explicit lambda code**, not reflection-based
- Type names are **fully qualified** (no type lookups needed)
- Dependencies are **statically known** from constructor analysis
- Everything is **compile-time verified**

### Phase 3: Runtime (Application Execution)

Your application code calls the generated method:

```csharp
using var container = new SvcContainer();
container.ConfigureGeneratedServices();  // ← Calls generated code

using var scope = container.CreateScope();
var user = scope.GetService<IUser>();  // ← Uses pre-generated factory
```

**Runtime operations**:
1. `ConfigureGeneratedServices()` executes generated code
2. Each `container.Register(descriptor)` adds the descriptor to cache
3. `GetService<T>()` looks up descriptor and calls its factory
4. Factory executes statically-typed code → **zero reflection**

## Register() Method: The Placeholder Pattern

### Design Pattern

```csharp
public class SvcContainer : ISvcContainer
{
    public ISvcContainer Register(SvcDescriptor descriptor)
    {
        ObjectDisposedException.ThrowIf(_disposed, this);
        
        // This is a placeholder. All real work is done by the source generator.
        // The descriptor passed here ALREADY contains a pre-built factory
        // (generated at compile-time), so we just register it as-is.
        RegisterDescriptorInternal(descriptor);
        return this;
    }

    private void RegisterDescriptorInternal(SvcDescriptor descriptor)
    {
        // Simple cache operation - no factory generation or reflection
        _descriptorCache.AddOrUpdate(
            descriptor.ServiceType,
            _ => [descriptor],
            (_, list) =>
            {
                list.Add(descriptor);
                return list;
            }
        );
    }
}
```

### Why This Design?

| Concern | Benefit |
|---------|---------|
| **No Runtime Factory Generation** | All factories exist as concrete code before runtime |
| **Zero Reflection** | Type information is not dynamically discovered |
| **AOT Compatible** | Native AOT has nothing to trim or trim-unsafely |
| **IL Trimmer Safe** | All types are statically referenced in generated code |
| **Performance** | Register() is O(1) dictionary insertion, GetService() is pure code execution |
| **Compile-Time Safety** | Errors detected during build, not at runtime |

## Extension Methods: The "Fluent" Layer

Extension methods on `ISvcContainer` are **also placeholders**:

```csharp
public static ISvcContainer RegisterSingleton<TService, TImpl>(
    this ISvcContainer container)
    where TImpl : TService
{
    // NOTE: This method does nothing at runtime!
    // The source generator scans for calls to this method
    // and generates all the actual registration code.
    return container;
}

public static ISvcContainer RegisterDecorator<TDecorator>(
    this ISvcContainer container,
    SvcLifetime lifetime = SvcLifetime.Transient)
    where TDecorator : class
{
    // Same pattern: source generator uses these calls as hints
    // to generate the actual decorator registration code.
    return container;
}
```

**How it works**:
1. You write: `container.RegisterSingleton<IUser, User>();`
2. Source generator **detects** this call during compilation
3. Generator **generates** the actual registration code
4. At runtime, the method is called but does nothing (or minimal validation)
5. The **generated** `ConfigureGeneratedServices()` does the real work

## Decorator Generic: Same Pattern

The decorator generic pattern follows the same design:

```csharp
// Phase 1: Compile-time
container.RegisterDecorator<Logger<>>();  // Generator detects this

// Phase 2: Code generation
// Generator produces:
container.RegisterTransient<Logger<IUser>>(
    scope => new Logger<IUser>(scope.GetService<IUser>())
);

// Phase 3: Runtime
var logger = scope.GetService<Logger<IUser>>();  // Uses pre-generated factory
```

## AOT Compatibility Guarantees

### ✅ No Dynamic Type Discovery
```csharp
// ❌ UNSAFE - Dynamic reflection
var type = Type.GetType("Namespace.ClassName");
Activator.CreateInstance(type);

// ✅ SAFE - Compile-time known type
var instance = new ClassName();  // or in our case...
static _ => new ClassName()      // Pre-generated lambda
```

### ✅ Generic Type Parameters Are Compile-Time Known
```csharp
// ✅ SAFE - Type parameter T is known at compile-time
static scope => new Container<TService>(...)  

// The CLR can generate exact IL without reflection
Activator.CreateInstance<T>()  // Where T is compile-time known
```

### ✅ No Type Metadata Trimming Issues
Because all types are:
- Explicitly referenced in generated code
- Never dynamically loaded
- Already proven used by the compiler

The IL trimmer will **never** remove them.

## Verification

To verify zero-reflection design:

1. **Build with source generator enabled**
   ```bash
   dotnet build
   ```
   
2. **Check generated code** (in `obj/Debug/net8.0/generated/`)
   ```
   Pico.DI.Gen/GeneratedServiceRegistrations.cs
   ```

3. **Verify no Activator.CreateInstance(Type)** in generated code
   - Only `new ClassName()` calls exist
   - Or generic `Activator.CreateInstance<T>()`

4. **Test with Native AOT**
   ```bash
   dotnet publish -c Release --self-contained -p PublishAot=true
   ```

## Summary Table

| Aspect | Traditional DI | Pico.DI |
|--------|----------------|---------|
| Factory Creation | Runtime + Reflection | Compile-time Code Gen |
| Registration Calls | Do the work | Placeholder (scanned only) |
| Type Discovery | Runtime reflection | Compile-time analysis |
| AOT Safety | Requires trimming hints | Zero configuration needed |
| Performance | ~1μs (with caching) | ~0.1μs (direct code) |
| Errors Detected | Runtime | Compile-time |
| Code Transparency | Implicit factories | Explicit generated code |

## Implementation Notes

### SvcContainer Disposal

Disposal still needs to handle singleton instances:
```csharp
public void Dispose()
{
    // Still needed: dispose cached singleton instances
    foreach (var descriptor in _descriptorCache.SelectMany(x => x.Value))
    {
        if (descriptor.SingleInstance is IDisposable disposable)
            disposable.Dispose();
    }
}
```

This is fine because:
- We're not reflecting on types to create them
- We're just managing lifecycle of already-created instances
- The instances themselves came from pre-generated factories

### GetService Resolution

Runtime GetService still needs standard DI operations:
```csharp
public object GetService(Type serviceType)
{
    if (!_descriptorCache.TryGetValue(serviceType, out var descriptors))
        throw new PicoDiException($"Service not registered: {serviceType}");
    
    // Call pre-generated factory (in descriptor)
    return descriptor.Factory(this);  // Zero reflection!
}
```

## Conclusion

Pico.DI's zero-reflection design is achieved by:
1. **Shifting factory generation from runtime to compile-time**
2. **Using source generators to analyze and produce explicit code**
3. **Making Register() a placeholder (scanned by compiler, no-op at runtime)**
4. **Pre-building all factories as static code before application runs**

This provides **maximum performance**, **zero AOT headaches**, and **compile-time safety**.

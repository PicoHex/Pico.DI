# Decorator Generic - Quick Reference

## One-Minute Quick Start

```csharp
// 1️⃣ Define Decorator
public class Logger<T> where T : class
{
    public Logger(T service) => _service = service;
    private readonly T _service;
}

// 2️⃣ Register
container
    .RegisterSingleton<IUserService, UserService>()
    .RegisterDecorator<Logger<>>();

// 3️⃣ Use
var logger = scope.GetService<Logger<IUserService>>();
```

## Core Concepts

| Concept | Description |
|---------|-------------|
| **Decorator Generic** | Open generic type (e.g., `Logger<T>`) that can wrap any registered service |
| **Compile-time Generation** | All factories are generated by source code generator at compile time |
| **Zero Reflection** | Fully AOT compatible, no runtime reflection |
| **Metadata** | `DecoratorMetadata` stores decorator configuration |

## API Quick Reference

### Register Decorator

```csharp
// Basic usage
container.RegisterDecorator<Logger<>>();

// With lifetime
container.RegisterDecorator<Logger<>>(SvcLifetime.Scoped);

// With parameter specification
container.RegisterDecorator<CachingDecorator<>>(
    lifetime: SvcLifetime.Singleton,
    decoratedServiceParameterIndex: 0
);

// Low-level API
container.RegisterDecorator(
    typeof(Logger<>),
    new DecoratorMetadata(typeof(Logger<>), SvcLifetime.Transient)
);
```

### Use Decorator

```csharp
// Auto resolve
var logger = scope.GetService<Logger<IUser>>();

// Nested decorator
var cached = scope.GetService<CachingDecorator<Logger<IUser>>>();

// Access decorated service
// (Depends on decorator implementation, usually provides GetService() or property)
var user = logger.Service.GetUser();
```

## Decorator Templates

### Simple Decorator

```csharp
public class Logger<T> where T : class
{
    private readonly T _inner;

    public Logger(T inner)
    {
        _inner = inner ?? throw new ArgumentNullException(nameof(inner));
        Console.WriteLine($"Logger<{typeof(T).Name}> initialized");
    }

    public T Service => _inner;
}
```

### Complex Decorator (Multiple Dependencies)

```csharp
public class CachingDecorator<T> where T : class
{
    private readonly T _service;
    private readonly ILogger _logger;

    // First parameter is the decorated service
    public CachingDecorator(T service, ILogger logger)
    {
        _service = service;
        _logger = logger;
    }
}
```

## Common Patterns

### Logging Decorator

```csharp
public class Logger<T> where T : class
{
    private readonly T _inner;
    private readonly ILog _log;

    public Logger(T inner, ILog log)
    {
        _inner = inner;
        _log = log;
    }

    public T Service
    {
        get
        {
            _log.Debug($"Accessing {typeof(T).Name}");
            return _inner;
        }
    }
}
```

### Caching Decorator

```csharp
public class CacheDecorator<T> where T : class
{
    private readonly T _inner;
    private readonly ICache _cache;

    public CacheDecorator(T inner, ICache cache)
    {
        _inner = inner;
        _cache = cache;
    }
}
```

### Validation Decorator

```csharp
public class ValidationDecorator<T> where T : class
{
    private readonly T _inner;
    private readonly IValidator _validator;

    public ValidationDecorator(T inner, IValidator validator)
    {
        _inner = inner;
        _validator = validator;
    }
}
```

## Configuration Examples

### ASP.NET Core

```csharp
builder.Services
    .AddSingleton<IUserService, UserService>()
    .RegisterDecorator<Logger<>>();
    // Convert to standard DI container
```

### Complete Example

```csharp
using var container = new SvcContainer();

container
    // Service registration
    .RegisterSingleton<IUserService, UserService>()
    .RegisterSingleton<IDatabaseService, DatabaseService>()
    .RegisterSingleton<ILogger, ConsoleLogger>()
    
    // Decorator registration
    .RegisterDecorator<Logger<>>(SvcLifetime.Transient)
    .RegisterDecorator<CachingDecorator<>>(SvcLifetime.Scoped);

// Configure services generated by source generator
container.ConfigureGeneratedServices();

// Use
using var scope = container.CreateScope();
var userLogger = scope.GetService<Logger<IUserService>>();
var dbCached = scope.GetService<CachingDecorator<IDatabaseService>>();
```

## Lifetime Rules

| Decorated Service | Decorator | Behavior |
|------------------|-----------|----------|
| Singleton | Transient | ✅ OK, creates new decorator wrapping shared service |
| Singleton | Singleton | ✅ OK, both decorator and service are singletons |
| Scoped | Transient | ✅ OK, creates new decorator each time |
| Scoped | Scoped | ✅ OK, both constrained to scope |
| Transient | Transient | ✅ OK, creates new instances each time |
| Transient | Singleton | ⚠️ Caution, decorates same transient multiple times |

## Constraints and Limitations

| Constraint | Description |
|-----------|-------------|
| **Must be generic** | `Logger<>` ✅, `Logger` ❌ |
| **Must be open generic** | `Logger<>` ✅, `Logger<IUser>` ❌ |
| **Must have constructor** | At least needs constructor accepting decorated service |
| **Compile-time detection** | Only explicit `GetService<T>()` calls in code are detected |
| **Decorated service must be registered** | Otherwise throws exception at runtime |

## Troubleshooting

### Problem: Decorator Not Injected

```csharp
// ❌ Wrong: Decorator not registered
var logger = scope.GetService<Logger<IUser>>();

// ✅ Correct: Register decorator first
container.RegisterDecorator<Logger<>>();
```

### Problem: Not Detected at Compile Time

```csharp
// ❌ Wrong: Dynamic construction, compiler cannot detect
var type = typeof(Logger<>).MakeGenericType(userServiceType);
var instance = scope.GetService(type);

// ✅ Correct: Explicit call, compiler can detect
var instance = scope.GetService<Logger<IUserService>>();
```

### Problem: Parameter Order Wrong

```csharp
// Decorated service parameter in decorator must be first
public class MyDecorator<T> where T : class
{
    // ✅ Correct
    public MyDecorator(T service, ILogger logger) { }
    
    // ❌ Wrong
    public MyDecorator(ILogger logger, T service) { }
}

// If not first, use parameter specification
container.RegisterDecorator<MyDecorator<>>(
    decoratedServiceParameterIndex: 1
);
```

## Performance Recommendations

1. **Use Singleton** when decorator itself is stateless
2. **Avoid deep decorator chains** (3+ levels may impact maintainability)
3. **Warm up cache** by calling `GetService<T>` once on app startup
4. **Monitor performance** using tools to measure decorator overhead

## Next Steps

- Read [Complete Guide](DECORATOR_GENERIC_GUIDE.md)
- See [Sample Application](samples/Pico.DI.Decorator.Sample/DecoratorGenericSample.cs)
- Run [Tests](tests/Pico.DI.Test/SvcContainerDecoratorGenericTests.cs)
